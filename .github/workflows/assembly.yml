# Builds the libtock_runtime entry point assembly, making sure the source code
# and compiled library match. Outputs the library file as an artifact in case
# users have a different toolchain version that produces a slightly different
# library.

name: assembly

# We want to run this on all pull requests. Additionally, Bors needs workflows
# to run on the `staging` and `trying` branches to block merges on them.
on:
  pull_request:
  push:
    branches:
      - staging
      - trying

jobs:
  assembly:
    # Using ubuntu-latest can cause breakage when ubuntu-latest is updated to
    # point at a new Ubuntu version. Instead, explicitly specify the version, so
    # we can update when we need to. This *could* break if we don't update it
    # until support for 20.04 is dropped, but it is likely we'll have a reason
    # to update to a newer Ubuntu before then anyway.
    runs-on: ubuntu-20.04

    steps:
      # Clones a single commit from the libtock-rs repository. The commit cloned
      # is a merge commit between the PR's target branch and the PR's source.
      # We'll later add another commit (the pre-merge target branch) to the
      # repository.
      - name: Clone repository
        uses: actions/checkout@v2.3.0

      # Build the entry point assembly.
      - name: Build assembly
        run: |
          sudo apt-get install binutils-riscv64-linux-gnu
          core/runtime/asm/assemble.sh

      # Publish the built assembly library.
      - name: Upload assembly library
        uses: actions/upload-artifact@v2
        with:
          name: assembly
          path: core/runtime/asm/*.a

      # The main goal of this is to verify the built library matches the PR's
      # library, although this check has the secondary benefit of catching any
      # intermediate files left behind by assemble.sh
      - name: Check assembly library diff
        run: git diff --quiet
